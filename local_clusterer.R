library(fastcluster)
library(ggplot2)
library(RColorBrewer)
library(dendextend)

# hierarchical clustering -------------------------------------------------

#' Perform agglomerative clustering on a single distance matrix.
#'
#' @param dist A distance matrix.
#' @param method A string to pass to [hclust] to determine clustering method.
#'
#' @return A dendrogram generated by `fastcluster`.
run_link <- function(dist, method) {
  if (!(inherits(dist, "dist")) & (any(is.na(dist)))) {
    return(vector())
  } else if (!(inherits(dist, "dist"))) {
    res = list(1)
    names(res) = dist
    return(res)
  } else {
    return(fastcluster::hclust(dist, method))
  }
}

#' Cut a dendrogram
#'
#' @param dend A single dendrogram.
#' @param cut_height A cut height value for the dendrogram.
#'
#' @return A named vector whose names are data point names and whose values are cluster labels.
#' @details Otherwise, we cut at the longest branch of the dendrogram to determine the number of clusters.
cut_dendrogram <- function(dend, cut_height) {
  # p = ggdendrogram(dend, rotate = FALSE, size = 2)
  # plot(p)
  return(cutree(dend, h = cut_height))
}

# cut many dendrograms at different heights
process_dendrograms <- function(dends, cut_heights) {
  if (inherits(dends, "hclust")) {
    return(cut_dendrogram(dends, cut_heights))
  }

  snipped_dends = mapply(cut_dendrogram,
                         dends,
			 cut_heights)
  return(snipped_dends)
}

#' Perform hierarchical clustering and process dendrograms.
#'
#' @param dist_mats A list of distance matrices to be used for clustering.
#' @param method A string to pass to [hclust] to tell it what kind of clustering to do.
#'
#' @return A list containing named vectors (one per dendrogram), whose names are data point names and whose values are cluster labels.
get_hierarchical_clusters <- function(dist_mats, method) {
  # do agglomerative clustering on distance matrices
  dends = lapply(dist_mats, run_link, method)

  max_dists = sapply(dist_mats, max)
  nonzero_max_dists = max_dists[max_dists != 0]

  # we would like to cut non-trivial dendrograms to determine number of clusters
  real_dends = dends[lapply(dends, length) > 1]
  imposter_dends = dends[lapply(dends, length) == 1]

#  sapply(real_dends, plot_dendrogram, method = method, cut_height = cut_height)

  # get cut heights of each dendrogram
  cut_heights = mapply(get_tallest_branch_height, real_dends, max_dists)

  # cut nontrival dendrograms and get clusters
  processed_dends = process_dendrograms(real_dends, cut_heights)

  # combine nontrival and trivial clusterings and return results
  if (length(imposter_dends) != 0) {
    return(append(processed_dends, sapply(imposter_dends, function(x)
      list(unlist(x))))) # LMAO what is this
  } else {
    return(processed_dends)
  }
}


#' Find the tallest branch of a dendrogram
#'
#' @param dend A single dendrogram.
#'
#' @return The height of the tallest branch (longest time between merge heights) of the input dendrogram.
get_tallest_branch_height <- function(dend, max_height) {
  heights = append(sort(unique(cophenetic(dend))), max_height)
  if (length(heights) <= 2) {
    return(max(heights))
  }
  branch_lengths = diff(heights) # differences are branch lengths

  tallest_branch_height = max(branch_lengths)
  tallest_branch_id = which(branch_lengths == tallest_branch_height)
  cutval = heights[tallest_branch_id] + .05*tallest_branch_height

  if (length(cutval) > 1) {
    cutval = sample(cutval, 1)
  }

  return(cutval)
}

#' Create a little dude to perform hierarchical clustering in a global context using the [hclust] package.
#'
#' @param method A string to pass to [hclust] to tell it what kind of clustering to do.
#'
#' @returns A function that inputs a list of distance matrices and returns a list containing one vector per bin, whose element names are data point names and whose values are cluster labels (within each bin).
#' @details This clusterer determines cutting heights for bin dendrograms generated by [hclust] by cutting them all at the same height.
#' @export
#'
#' @examples
#' data = data.frame(x = sapply(1:100, function(x) cos(x)), y = sapply(1:100, function(x) sin(x)))
#' projx = data$x
#'
#' num_bins = 10
#' percent_overlap = 25
#'
#' cover = create_width_balanced_cover(min(projx), max(projx), num_bins, percent_overlap)
#'
#' create_1D_mapper_object(data, dist(data), projx, cover, hierarchical_clusterer("mcquitty"))
local_tallest_hierarchical_clusterer <- function(method) {
#  plot_dendrogram(global_linkage, method, cut_height)
  return(function(dist_mats) get_hierarchical_clusters(dist_mats, method))
}
